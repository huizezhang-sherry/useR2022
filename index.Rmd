---
title: "cubble: An R Package for Organizing and Wrangling Multivariate Spatio-temporal Data"
author: |
  | Sherry Zhang
  | 
  | Joint work with Dianne Cook, Patricia Menéndez, Ursula Laa, and Nicolas Langrené
  | 
  | .pri[https://sherryzhang-user2022.netlify.app]
date: "2022-06-23"
output:
  xaringan::moon_reader:
    css: [xaringan-themer.css, other.css]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:9
      navigation:
        scroll: false 
        touch: true
        click: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      warning = FALSE, 
                      cache = TRUE, 
                      comment = NA,
                      fig.align='center')
wide_width <-  100
options(pillar.print_max = 5, 
        pillar.print_min = 5, 
        width = wide_width)


library(tidyverse)
library(tsibble)
library(cubble)
library(flair)
library(sf)
library(ggsvg)
light_purple <- colorRampPalette(c("black","#443750",  "white"))( 20 )[14]
light_pink <- colorRampPalette(c("#840032",  "white"))( 20 )[10]
```

```{r xaringan-scribble, echo=FALSE}
xaringanExtra::use_scribble()
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_duo_accent(
  primary_color = "#443750",  
  secondary_color = "#840032",
  title_slide_background_color = "#FFEECF",
  title_slide_text_color = "#443750",
  text_font_google = google_font("Atkinson Hyperlegible"),
  inverse_background_color = "#443750",
  header_font_google = google_font("Atkinson Hyperlegible"),
  header_background_padding = "1rem",
  header_background_content_padding_top = "6rem",
  text_font_size = "120%", 
  header_background_color = "#443750",
  header_background_auto = TRUE,
  code_inline_font_size = "0.9rem",
  link_color = "#FFEECF",
  inverse_link_color = "443750"
)
```


# Spatial data

.pull-left[

```{r}
ncs <- weatherdata::historical_tmax %>%
  filter(long > 151, lat < -32.5, lat > -33)

raw <- weatherdata::historical_tmax %>% 
  filter(between(stringr::str_sub(id, 7, 8), 46, 90)) %>% 
  filter(!id %in% c("ASN00071032", "ASN00071041", "ASN00063039")) %>%
  # remove sydney nearby (only leave sydney airport)
  filter(!id %in% c("ASN00063039", "ASN00066062", "ASN00066124",
                    "ASN00066137", "ASN00067033")) %>%
  # remove newcastle around area (only leave Nelson Bay)
  filter(!id %in% ncs$id[-1])

raw_stations <- raw %>% 
  select(id: wmo_id) %>% 
  ungroup()

stations_sf <- raw_stations %>%
  sf::st_as_sf(coords = c("long", "lat"), crs = 4283, remove = FALSE)
options(width = 50)
```

```{r echo = TRUE}
stations_sf 

```

```{r}
options(width = wide_width)
```

]

.pull-right[

```{r fig.retina=3}
nsw <- ozmaps::abs_ste %>% rmapshaper::ms_simplify() %>% filter(NAME %in% c("New South Wales", "Victoria"))

svg <- readLines(here::here("figures/station-icon.svg"))
station_svg <- paste(svg, collapse = "\n")
#grid::grid.draw(svg_to_rasterGrob(station_svg))

ggplot() +
  geom_sf(data = nsw, fill = "grey95", color = "white") +
  geom_point_svg(
    data = stations_sf,
    aes(long,lat),
    css("path:nth-child(1)", fill = "#443750"),
    css("path:nth-child(2)", fill = "#443750"),
    css("path:nth-child(3)", fill = "#443750"),
    css("path:nth-child(4)", fill = "#443750"),
    css("path:nth-child(5)", fill = "#443750"),
    svg = station_svg) + 
  scale_svg_default() + 
  ggthemes::theme_map() 
  
```

]

???

* Thanks everyone for coming 

* The title of my talk today is

* In my supervisor team are

* Here is the link to this slides, in case you would like to go back and forth while I'm talking

* Spatial data is common and here is a [...]

* The sf class uses a list column to store the feature geometries, including points, lines, polygons, multipolygons

* With the sf class, we can do various geometrical operations in the space

---

# Temporal data

.pull-left-narrow[

```{r}
ts <- raw %>% 
  face_temporal() %>% 
  as_tibble() %>% 
  tsibble::as_tsibble(key = id, index = date) %>% 
  filter(lubridate::year(date) >= 1971)
options(pillar.print_max = 10)
```

```{r echo = TRUE}
ts
```
]

```{r}
options(pillar.print_max = 5)
```

.pull-right-long[

```{r fig.retina=3, fig.width=10}
ts %>% 
  filter(lubridate::year(date) == 2020) %>% 
  ggplot(aes(x = date, y = tmax, group = id)) + 
  geom_line(alpha = 0.5, color = "#840032") +
  scale_x_date(date_breaks = "3 months", date_labels = "%Y %b") + 
  theme_bw()
```

]

???

* Temporal data is also common 

* Here we have an object named `ts`, which contains ...

* It is stored in a `tsibble` class with `id` as the key to define each series and `date` as the index to define the time stamp. 

* With the `tsibble` class, you can do many temporal wrangling and build temporal models. 

---

# Spatio-temporal data 

When left joining an `sf` object with a `tsibble`, the `tsibble` class gets lost: 

```{r echo = TRUE}
out <- stations_sf %>% left_join(ts, by = "id")
class(out)
```

When left joining the other way around, you lost the `sf` class:

```{r echo = TRUE}
out2 <- ts %>% left_join(stations_sf, by = "id")
class(out2)
```

???


* However, these spatial objects and temporal objects are punching each other's face when combined together for spatio-temporal analysis. 
* Here if I join ...

* if I join it ...

---

# Multivariate spatio-temporal data

You can manually coerce the joined object to have both classes:

```{r echo = TRUE}
out3 <- out2 %>% st_as_sf()
class(out3)
```

but the class lost again after a `tsibble` operation: 

```{r echo = TRUE}
out4 <- out3 %>% tsibble::fill_gaps()
class(out4)
```

???

* There is ways to enforce both the `tsibble` and `sf` class in the data object. 

* But the class label can still get lost when using operations from one class. 

* Here I use a tsibble function `fill_gaps` and the output no longer has the `sf` class

* Also, taking a step back, a simple join of the spatial and temporal data is not the best way to structure spatio-temporal data since all the feature geometries are repeated multiple times, especially for long daily data.  
---
class: center, inverse, middle

# Cubble

## A new tidy data structure to organise and wrangle spatio-temporal data

???

* This motivates a new data representation for spatio-temporal data

* Today I will introduce a new data structure, called cubble, to organise spatio-temporal data. 

* And we will see how wangling spatio-temporal data can be fun with cubble


---

# Multivariate spatio-temporal cubes

```{r}
knitr::include_graphics("figures/spatio-temporal-cube.png")
```


???

* To think about spatio-temporal data conceptually, we introduce a multivariate spatio-temporal cube

* Here the cube is defined slightly different from a conventional spatio-temporal cube. 

* Rather than stacking spatial snapshots across time, here the cube has three axes: Time, Site, and Variable

* Here latitude and longitude only takes one dimension as **Site** and make an assumption that an entity has a fixed location. 

* **Variable** is used to represent multivariate information in the spatio-temporal data. 

* We define the data in this way to avoid introducing hypercubes for multivariate information. 

* With this cube, operations on multivariate spatio-temporal data can be thought of as slicing and dicing on the cube. 

* While the data cube model is conceptually convenient for spatio-temporal data, it is not sufficiently rich for data wrangling. 

* Arrays are efficient for computing on numerical values, wrangling special date time classes can be difficult. 

* Thus for the convenient wrangling, we have designed a new spatio-temporal class, called cubble


---

# Cubble basics

```{r out.height=575}
knitr::include_graphics("figures/long-nested-form.png")
```


???

* The way cubble work is to organise the data in two forms

* Here I use two colors to represent the spatial and temporal variables

* The nested cubble has each site in a row 

* It has spatial variables like longitude, latitude, among others and temporal variables all nested in a ts column. 

* In the long cubble, each row is identified by a combination of site and date. 
  
* spatial variables are stored separately as the data attributes, which I will later show you through the code
  
---
# Switching focus between time and space

```{r out.height=575}
knitr::include_graphics("figures/cubble-operations.png")
```

???

* Here is how you can switch between the nested and long form

* The verb `face_temporal()` switches the nested cubble into the long form and

* This change the focus from the spatial to temporal aspect and the resulting long form can be used to summarise the temporal aspect of the data.

* The inverse of `face_temporal()` is `face_spatial()`, which switches the long cubble into a nested one

* This changes the focus back to the spatial aspect and can be used to view the spatial distribution of variables on the map

---

# Creating a cubble

```{r echo = TRUE}
weather <- as_cubble(list(spatial = stations_sf, temporal = ts),
  key = id, index = date, coords = c(long, lat))

weather
```

???

* Now I'm going to show you how to create a cubble from the spatial and temporal data we have seen before.

* Here you specify the spatial and temporal object in a list with name `spatial` and `temporal`. 

* Then you can specify the `key` and `index` as what you would do  when creating a `tsibble` and `coords` in the order of longitude and latitude. 

--

- There are .sec[`r nrow(stations_sf)`] stations in this data, it is in the nested form and is a subclass of `sf` 
- Temporal variables are `date`, and `tmax`. Spatial variables: `long, lat, elev, name`, and `wmo_id`
- Each temporal component is a tsibble (`tbl_ts`) containing temporal information


???

* By default, this create a nested cubble. 

* There is a header summary on cubble objects, here it tells you

---
# Cubble summary (1/2)

.pull-left-larger[

```{r echo = FALSE}
options(width = 50)
```

```{r face-temporal, eval = FALSE}
weather_long <- weather %>% face_temporal()
weather_long
```

```{r echo = FALSE}
decorate_chunk("face-temporal") %>%
  flair("face_temporal()", background = "#FFEECF") %>% 
  knit_print.with_flair(width = 50)
```

  - now it is a long form cubble and is a subclass of `tsibble`
  
  - the third row now shows the spatial variables

]

--

.pull-right[

```{r echo = TRUE}
attr(weather_long, "spatial") 
```
  

]

???

* This is what the long cubble looks like

---
# Cubble summary (2/2)

```{r echo = FALSE}
options(width = wide_width)
```

```{r face-spatial, eval = FALSE}
weather_back <- weather_long %>% face_spatial()
weather_back

identical(weather_back, weather)
```

```{r echo = FALSE}
decorate_chunk("face-spatial") %>%
  flair("face_spatial()", background = "#FFEECF") %>% 
  knit_print.with_flair()
```
???

* An example of face_spatial() is shown here where you can get the long form back to the nested form. 

* And the output will be identical to the initial cubble `weather` data we created earlier

---

# Pipeline with cubble

.pull-left-narrow[
```{r cb-code, eval = FALSE}
cb_obj %>% 
  {{ Your spatial analysis }} %>% 
  face_temporal() %>% 
  {{ Your temporal analysis }} %>% 
  face_spatial() %>% 
  {{ Your spatial analysis }} 
```


```{r echo = FALSE}
decorate_chunk("cb-code", eval = FALSE) %>%
  flair("{{ Your spatial analysis }}" , background = light_purple) %>% 
  flair("{{ Your temporal analysis }}" , background = light_pink) %>% 
  flair("face_temporal()" , background = "#FFEECF") %>% 
  flair("face_spatial()" , background = "#FFEECF") %>% 
  knit_print.with_flair()

```

]

.pull-right-long[
```{r conv-code, eval = FALSE}
spatial <- stations_sf %>% 
  {{ Your spatial analysis }} 

##############################
# more subsetting step if temporal analysis
# depends on spatial results
sp_id <- spatial %>% pull(id)
ts_subset <- ts %>% filter(id %in% sp_id)
##############################

temporal <- ts_subset %>% 
  {{ Your temporal analysis }} 

##############################
# more subsetting step if spatial analysis 
# depends on temporal results
ts_id <- temporal %>% pull(id)
sp_subset <- spatial %>% filter(id %in% ts_id)
##############################

sp_subset %>% 
  {{ Your spatial analysis }} 
  
```

<!-- # "#443750",  secondary_color = "#840032", -->
```{r echo = FALSE}

decorate("conv-code", eval = FALSE) %>%
  flair("{{ Your spatial analysis }}" , background = light_purple) %>% 
  flair("{{ Your temporal analysis }}" , background = light_pink) %>% 
  flair("sp_id <- spatial %>% pull(id)" , background = "#FFEECF") %>% 
  flair("ts_subset <- ts %>% filter(id %in% sp_id)" , background = "#FFEECF") %>% 
  flair("ts_id <- temporal %>% pull(id)" , background = "#FFEECF") %>% 
  flair("sp_subset <- spatial %>% filter(id %in% ts_id)" , background = "#FFEECF") %>% 
  knit_print.with_flair()
```
]


???

* In summary, with cubble, you can perform temporal analysis in the long form, and pivot to the nested form for some spatial analysis, and pivot back to the the long form for some other temporal analysis. 

* Sometimes, you may also need to do some analysis that involves both spatial and temporal variables. 

* Here I will show you how to do that in cubble with an example of making glyph maps.

---
# Transform a dot into a glyph

```{r}
knitr::include_graphics(here::here("figures/glyph-steps1.png"))
```

---
# Transform a dot into a glyph

```{r}
knitr::include_graphics(here::here("figures/glyph-steps2.png")) 
```

---
# Transform a dot into a glyph


```{r}
knitr::include_graphics(here::here("figures/glyph-steps3.png"))
```

---
# Transform a dot into a glyph

```{r out.height="100%"}
knitr::include_graphics(here::here("figures/glyph-steps4.png"))
```


???

* A glyph map is a transformation of temporal variables into space. 
* Here I have 5 locations, each has a time series. 

* A glyph map transforms the scale of the time series into the spatial map, so that temporal information can be visualised in a map

* To create a glyph map, you will need information on the spatial coordinates, longitude and latitude, which we call the major axes, and the temporal coordinates, date and value, the minor axes.
---

# Transformation to glyphmap

<!-- (context of problem): compare seasonal temperature for two periods  -->

<!-- drop missing -->
<!-- migrate  -->
<!-- transform -->

<!-- What if you want to work with  both spatial or temporal variables? -->

.pull-left[
```{r out.height = 400, out.width = 500}
knitr::include_graphics("figures/migrate.png")
```

]

.pull-right-larger[
```{r}
options(width = 60)
```


```{r unfold, eval = FALSE}
cb_migrated <- weather_long %>% unfold(long, lat)
cb_migrated
```


```{r echo = FALSE}
decorate_chunk("unfold") %>%
  flair("unfold()", background = "#FFEECF") %>% 
  knit_print.with_flair(width = 50)
```
]

???

* In a cubble, the major coordinates are stored in the nested form, while minor coordinates are stored in the long form.  

* In cubble you can use the verb `unfold()` to relocate spatial variables into the long form. 

* This is in essence a join operation 

* On the right shows an example of unfold long and lat with the weather data.

---

# Example: Australian temperature

```{r}
knitr::include_graphics(here::here("figures/temperature-workflow.png"))
```



???

* Now combine everything I have just introduced, here is an example of using cubble to analyse historical temperature

* The data used for this example has a similar structure as before has a long period that dated back to the 70s, so we can compare how the maximum temperature looks like in the past and nowadays

* The diagram here shows how different steps in the data analysis can be chained together with cubble 

* Start with all Australia data, we can first filter out the NSW stations in the space, and then stretch to the long form to filter on the two time periods

* Then with the long form, the maximum temperature is summarised into monthly average

* In step 4 we switch back to the nested form to find that some stations don't have history records and drop those

* In step 5, we switch to the long form again and migrate the longitude and latitude to prepare for the glyph map transformation. 

* And lastly the glyphmap transformation gives you a map.

---


.pull-left-larger[

<br>

```{r glyph, eval = FALSE}
tmax <- DATA %>% 
  filter(NSW_STATIONS) %>% 
  face_temporal() %>% 
  filter(DATE_IN_TWO_GROUPS) %>% 
  summarise() %>% 
  face_spatial() %>% 
  filter(NO_MISSING_VALUE) %>% 
  face_temporal() %>% 
  unfold(long, lat)

tmax %>% 
  ggplot(aes(x_minor = lubridate::month(date), 
             y_minor = tmax, 
             x_major = long, 
             y_major = lat)) + 
  geom_glyph_box() + 
  geom_glyph()
```

```{r echo = FALSE}
decorate_chunk("glyph", eval = FALSE) %>%
  flair("face_spatial", background = "#FFEECF") %>% 
  flair("face_temporal", background = "#FFEECF") %>% 
  flair("unfold", background = "#FFEECF") %>% 
  flair("geom_glyph_box", background = "#FFEECF") %>% 
  flair("geom_glyph", background = "#FFEECF") %>% 
  knit_print.with_flair()
```

]

.pull-right[

```{r inset, eval = FALSE}
tmax |> filter(id == "ASN00048027") |>
  ggplot(aes(x = month,
             y = tmax,
             color = group)) +
  geom_line(size = 1.5) +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  scale_x_continuous(breaks = seq(1, 12, 1), 
                     labels = c("J", "F", "M", "A", "M", "J", 
                                "J", "A", "S", "O", "N", "D")) +
  labs(x = "", y  = "Temp (C)", title = "ASN00048027: Cobar") +
  theme_bw() +
  theme(
    aspect.ratio = 0.3,
    axis.text = element_text(size = 20),
    title =  element_text(size = 20)
  )
ggsave(filename = here::here("figures/cobar-inset.png"), width = 7, height = 3)
```

```{r fig.retina=3}
tmax <- weatherdata::historical_tmax %>% 
  filter(between(stringr::str_sub(id, 7, 8), 46, 90)) |>
   filter(!id %in% c("ASN00071032", "ASN00071041", "ASN00063039")) %>%
  # remove sydney nearby (only leave sydney airport)
  filter(!id %in% c("ASN00063039", "ASN00066062", "ASN00066124",
                    "ASN00066137", "ASN00067033")) %>%
  # remove newcastle around area (only leave Nelson Bay)
  face_temporal() |>
  filter(lubridate::year(date) %in% c(1971:1975, 2016:2020)) %>% 
  group_by(month = lubridate::month(date),
           group = as.factor(ifelse(lubridate::year(date) > 2015,
                                    "2016 ~ 2020", "1971 ~ 1975"))) |>
  summarise(tmax = mean(tmax, na.rm = TRUE)) %>% 
  face_spatial() |> 
  filter(nrow(ts) == 24) %>% 
  face_temporal() |> 
  unfold(long, lat)

nsw_vic <- ozmaps::abs_ste |> filter(NAME %in% c("Victoria", "New South Wales"))

p1 <- ggplot() + 
  geom_sf(data = nsw_vic, fill = "grey95", color = "white") + 
  geom_glyph(data = tmax, 
             aes(x_major = long, x_minor = month, 
                 y_major = lat, y_minor = tmax,
                 group = interaction(id, group), 
                 color = group),
             width = 1, height = 0.5) +
  scale_color_brewer("", palette = "Dark2") + 
  coord_sf(xlim = c(141, 154), ylim = c(-39, -28.5)) + 
  ggthemes::theme_map() +
  theme(legend.position = "bottom") +
  labs(x = "Longitude", y = "Latitude")

box_df <- tmax |> face_spatial() |> filter(id == "ASN00048027")
single <- tibble::tibble(img = here::here("figures/cobar-inset.png"))

p1 +
  geom_rect(data = box_df,
            aes(xmin = long - 0.6, xmax = long + 0.6,
                ymin = lat - 0.12, ymax = lat + 0.35),
            fill = "transparent", color = "black") +
  ggimg::geom_point_img(
    data = single, aes(x = 143.5, y = -30, img = img), size = 6)
```


]

???

* This is the code version of the previous diagram and the functions highlighted here are I developed in cubble

* In the plot, I show an enlarged legend of one station Cobar

* In each glyph, I plot the averaged maximum temperature for September to February for the two periods

* One information I read from this plot is in the past, the average maximum temperature from December to February are almost the same, while these days, January stands out to be hotter for the inland stations



```{r}
map <- ozmaps::abs_ste %>% rmapshaper::ms_simplify()
nsw <- map %>% filter(NAME == "New South Wales")
```


---
class: inverse, middle

# More you can do with cubble

* Merge two data sources by spatial and temporal similarities

--

* Alternative objects accepted as components:

  * Spatial data can be represented as an .inverse-code[sf] or .inverse-code[S2 LngLat], spatial objects

  * Temporal data can be represented as a .inverse-code[tsibble], a special temporal data object

--

* Input data can be of various forms, including .inverse-code[netCDF] and .inverse-code[tibble variates] (i.e. grouped and rowwise data frame)

---
background-image: url("figures/3cubes-in-one.png")
background-position: 90% 70%
background-size: 280px, 280px

class: inverse,  middle

# Additional Information

Slides created via the R package [.inverse-code[xaringan]](https://github.com/yihui/xaringan) and [.inverse-code[xaringanthemer]](https://github.com/gadenbuie/xaringanthemer), available at 

.center[https://sherryzhang-user2022.netlify.app]

<br>

.inverse-code[`r fontawesome::fa("link")`] cubble package: https://github.com/huizezhang-sherry/cubble

<br>

H. Sherry Zhang [.inverse-code[`r fontawesome::fa("github")`]](https://github.com/huizezhang-sherry)

Collaborators: Dianne Cook, Patricia Menéndez, Ursula Laa, and Nicolas Langrené



