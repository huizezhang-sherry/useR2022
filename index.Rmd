---
title: "cubble: An R Package for Organizing and Wrangling Multivariate Spatio-temporal Data"
author: |
  | Sherry Zhang
  | 
  | Collaborators: Dianne Cook, Patricia Menéndez, Ursula Laa, and Nicolas Langrené
  | 
  | .pri[https://sherryzhang-user2022.netlify.app]
date: "2022-06-23"
output:
  xaringan::moon_reader:
    css: [xaringan-themer.css, other.css]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:9
      navigation:
        scroll: false 
        touch: true
        click: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      warning = FALSE, 
                      cache = TRUE, 
                      comment = NA,
                      fig.align='center')

options(pillar.print_max = 5, pillar.print_min = 5, width = 45)
library(tidyverse)
library(cubble)
library(flair)
library(sf)
```


```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_duo_accent(
  primary_color = "#443750",  
  secondary_color = "#840032",
  title_slide_background_color = "#FFEECF",
  title_slide_text_color = "#443750",
  text_font_google = google_font("Atkinson Hyperlegible"),
  inverse_background_color = "#443750",
  header_font_google = google_font("Atkinson Hyperlegible"),
  header_background_padding = "1rem",
  header_background_content_padding_top = "6rem",
  text_font_size = "120%", 
  header_background_color = "#443750",
  header_background_auto = TRUE,
  code_inline_font_size = "0.9rem",
  link_color = "#FFEECF",
  inverse_link_color = "443750"
)
```


# Multivariate spatio-temporal data

```{r}
raw <- weatherdata::historical_tmax %>% 
  filter(between(stringr::str_sub(id, 7, 8), 46, 75))

raw_stations <- raw %>% 
  select(id: wmo_id) %>% 
  ungroup()

stations_sf <- raw_stations %>%
  sf::st_as_sf(coords = c("long", "lat"), crs = 4283, remove = FALSE)
```

```{r echo = TRUE}
stations_sf 
```


???

* Thanks everyone for coming 

* The title of my talk today is

* In my supervisor team are

* Here is the link to this slides, in case you would like to go back and forth while I'm talking

* MST data are commonly collected in different areas  

* some examples of these include 

  * climate variables measured by weather stations over time, 
  
  * pollutant data monitored by air quality meters, and 
  
  * river level data recorded by river gauges over different periods.


---

# Multivariate spatio-temporal data

```{r}
ts <- raw %>% face_temporal() %>% tsibble::as_tsibble(key = id, index = date)
```

```{r echo = TRUE}
ts
```


???

* Conceptually MST data can be thought of as a data cube with three axes: site, time, and variable



---

# Multivariate spatio-temporal data

When left joining an `sf` object with a `tsibble`, the `tsibble` class gets lost: 

```{r echo = TRUE, echo = TRUE}
out <- stations_sf %>% left_join(ts, by = "id")
class(out)
```

When left joining the other way around, you lost the `sf` class:

```{r eval = FALSE, echo = TRUE}
out2 <- ts %>% left_join(stations_sf, by = "id")
out2 %>% st_filter(nsw, .predicate = st_within)
```

Error in UseMethod("st_filter") :
   no applicable method for 'st_filter' applied to an object of class "c('tbl_ts', 'tbl_df', 'tbl', 'data.frame')"

---

# Multivariate spatio-temporal data


When you finally have both `sf` and `tsibble` in your class, the `sf` class is gone when apply a method from `tsibble`: 

```{r eval = FALSE, echo = TRUE}
out3 <- out2 %>% 
  filter(lubridate::year(date) %in% c(1971:1975, 2016:2020)) %>% 
  filter(!(lubridate::year(date) == 1971 & lubridate::month(date) == 2)) %>% 
  st_as_sf()
out3
class(out3)

out3 %>% tsibble::fill_gaps()
```

???

* And to analyse this type of data, we can

  * fix the time to look at the spatial distribution of variables; 
  * fix the location to look at the temporal variation, like trend and seasonality; or 
  * look at relationship among variables across time and space

---

# Motivation 

* Multivariate spatio-temporal data usually come in multiple pieces

* Existing spatial and temporal data structure don't seem to live happily together

* A new data structure, `cubble`, that
  * organises different pieces in a single data object
  * allows users to access variables easily in the analysis

???

* Now let's change the topic and look at some climate data

* NOAA hosts worldwide climate data

* To get data from there, you will first need to query the locations and variables of interest. This gives a spatial table on the top

* Then you will query the temporal information based on the spatial table

* This is an example where MST

* Today I will introduce a new data structure, cubble, that allows you to organise spatio-temporal data in a different way

* so that different pieces of information all live in a single data object and users can easily access variables during the analysis

* I will illustrate the data structure with three examples in this talk

---

# Spatio-temporal cubes

```{r}
knitr::include_graphics("figures/spatio-temporal-cube.png")
```



---

# Cubble basics

```{r out.height=575}
knitr::include_graphics("figures/long-nested-form.png")
```


???

* The way cubble work is to organise the data in two forms

* Here I use two colors to represent the spatial and temporal variables

* The nested cubble has each location in a row 

* It has spatial variables like longitude, latitude, among others and temporal variables all nested in a ts column. 

* In the long cubble, each row is identified by a combination of location and date. 
  
* spatial variables are stored separately as the data attributes, which I will later show you through the code
  
---
# Switching focus between time and space

```{r out.height=575}
knitr::include_graphics("figures/cubble-operations.png")
```

???

* Here is how you can switch between the nested and long form

* The verb `stretch()` switches the nested cubble into the long form and

* This change the focus from the spatial to temporal aspect and the resulting long form can be used to summarise the temporal aspect of the data.

* The inverse of `stretch()` is `tamp()`, which switches the long cubble into a nested one

* This changes the focus back to the spatial aspect and can be used to view the spatial distribution of variables on the map

---

# Creating a cubble

```{r echo = TRUE}
weather <- as_cubble(
  list(spatial = stations_sf, temporal = ts),
  key = id, 
  index = date, 
  coords = c(long, lat))

weather
```


???

* Now I'm going to show you how cubble looks like in the code

* With the spatial and temporal table I show you early one, there are different ways you can cast them into a cubble

* The first one joins the two tables by id into a combined data, and

* The second one uses a rowwise structure to query the temporal variables directly into a list column, you can see the header here it is a rowwise data frame and each element in the `ts` column has 366 rows and four variables

* With either form, you can use `as_cubble` function and supply three arguments, the key, the index, and the coordinates, which are the three important information in MST data


---

# Cubble summary (1/2)

```{r eval = FALSE, echo = TRUE}
weather
```

```{r}
options(width = 345)
weather
```

???

* By default, this create a nested cubble. 

* There is a header summary on cubble objects, here it tells you


--

- There are .sec[638] stations in this data 
- Temporal variables are `date, prcp, tmax`, and `tmin`
- Spatial variables: `lat, long, elev, name`, and `wmo_id`
- Each temporal component is a tibble, .sec[366] rows for each station

---

# Cubble summary (2/2)

.pull-left[
```{r}
weather_long <- weather %>% face_temporal()
options(width = 45)
```

```{r echo = TRUE}
weather_long <- weather %>% face_temporal()
weather_long
```


]

???

* This is what the long cubble looks like

---
# Cubble summary (2/2)


.pull-left[
```{r}
weather_long <- weather %>% face_temporal()
options(width = 45)
```

```{r echo = TRUE}
weather_long <- weather %>% face_temporal()
weather_long
```


* Notice: `# spatial: lat [dbl], long [dbl], elev [dbl], name [chr], wmo_id [dbl]`


]

--

.pull-right[
```{r echo = TRUE, results='hold'}
attr(weather_long, "spatial")
# or you can use: spatial(climate_long)
```

]


---

# Transformation to glyphmap

<!-- (context of problem): compare seasonal temperature for two periods  -->

<!-- drop missing -->
<!-- migrate  -->
<!-- transform -->

<!-- What if you want to work with  both spatial or temporal variables? -->

.pull-left[
```{r out.height = 400, out.width = 500}
knitr::include_graphics("figures/migrate.png")
```

]

???

* With cubble, you can also do some spatio-temporal transformation and the particular one we will talk about today is the glyph map. 

* A glyph map requires both spatial and temporal variables for the transformation.

* In this transformation, you need longitude, latitude, and the variable of interest across time

* In cubble you can temporarily move some spatial variables into the long form using the verb `migrate()`

* Here is the illustrate and the code shows you with the long form, you migrate long and lat


--

.pull-right-larger[
```{r}
options(width = 60)
```


```{r echo = TRUE}
cb_migrated <- weather_long %>% 
  unfold(long, lat)
cb_migrated
```
]


---

# Example: Australian temperature

```{r}
knitr::include_graphics(here::here("figures/temperature-workflow.png"))
```



???

* Here is a much involved example of comparing Australia temperature in two time periods

* The data used for this example has a simlar structure as before has a long period that dated back to the 70s, so we can compare how the maximum temperature looks like in the past and nowadays

* The diagram here shows how different steps in the data analysis can be chained together with cubble 

* Start with all Australia data, we can first filter out the NSW stations in the space, and then stretch to the long form to filter on the two time periods

* Then with the long form, the maximum temperature is summarised into monthly average

* In step 4 we switch back to the nested form to find that some stations don't have history records and drop those

* In step 5, we switch to the long form again and migrate the longitude and latitude to prepare for the glyph map transformation. 

* And lastly the glyphmap transformation gives you a map.

---


.pull-left-larger[

```{r glyph, eval = FALSE}
tmax <- DATA %>% 
  filter(NSW_STATIONS) %>% 
  face_temporal() %>% 
  filter(DATE_IN_TWO_GROUPS) %>% 
  summarise() %>% 
  face_spatial() %>% 
  filter(NO_MISSING_VALUE) %>% 
  face_temporal() %>% 
  unfold(long, lat)

tmax %>% 
  ggplot(aes(x_minor = lubridate::month(date), 
             y_minor = tmax, 
             x_major = long, 
             y_major = lat)) + 
  geom_glyph_box() + 
  geom_glyph()
```

```{r echo = FALSE}
flair::decorate_chunk("glyph", eval = FALSE) %>%
  flair::flair("face_spatial", background = "#FFEECF") %>% 
  flair::flair("face_temporal", background = "#FFEECF") %>% 
  flair::flair("unfold", background = "#FFEECF") %>% 
  flair::flair("geom_glyph_box", background = "#FFEECF") %>% 
  flair::flair("geom_glyph", background = "#FFEECF") %>% 
  flair::knit_print.with_flair()
```

]

.pull-right[
```{r}
knitr::include_graphics(here::here("figures/glyphmap.png"))
```


]

???

* This is the code version of the previous diagram and the functions highlighted here are I developed in cubble

* In the plot, I show an enlarged legend of one station Cobar

* In each glyph, I plot the averaged maximum temperature for September to February for the two periods

* One information I read from this plot is in the past, the average maximum temperature from December to February are almost the same, while these days, January stands out to be hotter for the inland stations



```{r}
map <- ozmaps::abs_ste %>% rmapshaper::ms_simplify()
nsw <- map %>% filter(NAME == "New South Wales")
```


---
class: inverse, middle

# More you can do with cubble

* Merge two data sources by spatial and temporal similarities

--

* Alternative objects accepted as components:

  * Spatial data can be represented as an .inverse-code[sf] or .inverse-code[S2 LngLat], spatial objects

  * Temporal data can be represented as a .inverse-code[tsibble], a special temporal data object

--

* Input data can be of various forms, including .inverse-code[netCDF] and .inverse-code[tibble variates] (i.e. grouped and rowwise data frame)

---
background-image: url("figures/3cubes-in-one.png")
background-position: 90% 70%
background-size: 280px, 280px

class: inverse,  middle

# Additional Information

Slides created via the R package [.inverse-code[xaringan]](https://github.com/yihui/xaringan) and [.inverse-code[xaringanthemer]](https://github.com/gadenbuie/xaringanthemer), available at 

.center[https://sherryzhang-user2022.netlify.app]

<br>

.inverse-code[`r fontawesome::fa("link")`] cubble package: https://github.com/huizezhang-sherry/cubble

<br>

H. Sherry Zhang [.inverse-code[`r fontawesome::fa("github")`]](https://github.com/huizezhang-sherry)

Collaborators: Dianne Cook, Patricia Menéndez, Ursula Laa, and Nicolas Langrené



