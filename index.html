<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>cubble: An R Package for Organizing and Wrangling Multivariate Spatio-temporal Data</title>
    <meta charset="utf-8" />
    <meta name="date" content="2022-06-23" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="other.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# cubble: An R Package for Organizing and Wrangling Multivariate Spatio-temporal Data
]
.author[
### <div class="line-block">Sherry Zhang<br />
<br />
Joint work with Dianne Cook, Patricia Menéndez, Ursula Laa, and Nicolas Langrené<br />
<br />
.pri[<a href="https://sherryzhang-user2022.netlify.app" class="uri">https://sherryzhang-user2022.netlify.app</a>]</div>
]
.date[
### 2022-06-23
]

---









# Spatial data

.pull-left[




```r
stations_sf
```

```
Simple feature collection with 59 features and 6 fields
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 141.2652 ymin: -39.1297 xmax: 153.3633 ymax: -28.9786
Geodetic CRS:  GDA94
# A tibble: 59 × 7
  id           long   lat  elev name        wmo_id
* &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;
1 ASN00047016  141. -34.0    43 lake victo…  94692
2 ASN00047019  142. -32.4    61 menindee p…  94694
3 ASN00048015  147. -30.0   115 brewarrina…  95512
4 ASN00048027  146. -31.5   260 cobar mo     94711
5 ASN00048031  149. -29.5   145 collareneb…  95520
# … with 54 more rows, and 1 more variable:
#   geometry &lt;POINT [°]&gt;
```



]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-4-1.png" width="504" style="display: block; margin: auto;" /&gt;

]

???

* Thanks everyone for coming 

* The title of my talk today is

* In my supervisor team are

* Here is the link to this slides, in case you would like to go back and forth while I'm talking

* Spatial data is common and here is a [...]

* The sf class uses a list column to store the feature geometries, including points, lines, polygons, multipolygons

* With the sf class, we can do various geometrical operations in the space

---

# Temporal data

.pull-left-narrow[




```r
ts
```

```
# A tsibble: 1,099,052 x 3 [1D]
# Key:       id [59]
  id          date        tmax
  &lt;chr&gt;       &lt;date&gt;     &lt;dbl&gt;
1 ASN00047016 1971-01-01  25  
2 ASN00047016 1971-01-02  26.9
3 ASN00047016 1971-01-03  27.5
4 ASN00047016 1971-01-04  30  
5 ASN00047016 1971-01-05  34.4
# … with 1,099,047 more rows
```
]



.pull-right-long[

&lt;img src="index_files/figure-html/unnamed-chunk-8-1.png" width="720" style="display: block; margin: auto;" /&gt;

]

???

* Temporal data is also common 

* Here we have an object named `ts`, which contains ...

* It is stored in a `tsibble` class with `id` as the key to define each series and `date` as the index to define the time stamp. 

* With the `tsibble` class, you can do many temporal wrangling and build temporal models. 

---

# Spatio-temporal data 

When left joining an `sf` object with a `tsibble`, the `tsibble` class gets lost: 


```r
out &lt;- stations_sf %&gt;% left_join(ts, by = "id")
class(out)
```

```
[1] "sf"         "tbl_df"     "tbl"        "data.frame"
```

When left joining the other way around, you lost the `sf` class:


```r
out2 &lt;- ts %&gt;% left_join(stations_sf, by = "id")
class(out2)
```

```
[1] "tbl_ts"     "tbl_df"     "tbl"        "data.frame"
```

???


* However, these spatial objects and temporal objects are punching each other's face when combined together for spatio-temporal analysis. 
* Here if I join ...

* if I join it ...

---

# Multivariate spatio-temporal data

You can manually coerce the joined object to have both classes:


```r
out3 &lt;- out2 %&gt;% st_as_sf()
class(out3)
```

```
[1] "sf"         "tbl_ts"     "tbl_df"     "tbl"        "data.frame"
```

but the class lost again after a `tsibble` operation: 


```r
out4 &lt;- out3 %&gt;% tsibble::fill_gaps()
class(out4)
```

```
[1] "tbl_ts"     "tbl_df"     "tbl"        "data.frame"
```

???

* There is ways to enforce both the `tsibble` and `sf` class in the data object. 

* But the class label can still get lost when using operations from one class. 

* Here I use a tsibble function `fill_gaps` and the output no longer has the `sf` class

* Also, taking a step back, a simple join of the spatial and temporal data is not the best way to structure spatio-temporal data since all the feature geometries are repeated multiple times, especially for long daily data.  
---
class: center, inverse, middle

# Cubble

## A new tidy data structure to organise and wrangle spatio-temporal data

???

* This motivates a new data representation for spatio-temporal data

* Today I will introduce a new data structure, called cubble, to organise spatio-temporal data. 

* And we will see how wangling spatio-temporal data can be fun with cubble


---

# Multivariate spatio-temporal cubes

&lt;img src="figures/spatio-temporal-cube.png" width="2532" style="display: block; margin: auto;" /&gt;


???

* To think about spatio-temporal data conceptually, we introduce a multivariate spatio-temporal cube

* Here the cube is defined slightly different from a conventional spatio-temporal cube. 

* Rather than stacking spatial snapshots across time, here the cube has three axes: Time, Site, and Variable

* Here latitude and longitude only takes one dimension as **Site** and make an assumption that an entity has a fixed location. 

* **Variable** is used to represent multivariate information in the spatio-temporal data. 

* We define the data in this way to avoid introducing hypercubes for multivariate information. 

* With this cube, operations on multivariate spatio-temporal data can be thought of as slicing and dicing on the cube. 

* While the data cube model is conceptually convenient for spatio-temporal data, it is not sufficiently rich for data wrangling. 

* Arrays are efficient for computing on numerical values, wrangling special date time classes can be difficult. 

* Thus for the convenient wrangling, we have designed a new spatio-temporal class, called cubble


---

# Cubble basics

&lt;img src="figures/long-nested-form.png" width="2560" height="575" style="display: block; margin: auto;" /&gt;


???

* The way cubble work is to organise the data in two forms

* Here I use two colors to represent the spatial and temporal variables

* The nested cubble has each site in a row 

* It has spatial variables like longitude, latitude, among others and temporal variables all nested in a ts column. 

* In the long cubble, each row is identified by a combination of site and date. 
  
* spatial variables are stored separately as the data attributes, which I will later show you through the code
  
---
# Switching focus between time and space

&lt;img src="figures/cubble-operations.png" width="2560" height="575" style="display: block; margin: auto;" /&gt;

???

* Here is how you can switch between the nested and long form

* The verb `face_temporal()` switches the nested cubble into the long form and

* This change the focus from the spatial to temporal aspect and the resulting long form can be used to summarise the temporal aspect of the data.

* The inverse of `face_temporal()` is `face_spatial()`, which switches the long cubble into a nested one

* This changes the focus back to the spatial aspect and can be used to view the spatial distribution of variables on the map

---

# Creating a cubble


```r
weather &lt;- as_cubble(list(spatial = stations_sf, temporal = ts),
  key = id, index = date, coords = c(long, lat))

weather
```

```
# cubble:   id [59]: nested form [sf]
# bbox:     [141.26, -39.13, 153.37, -28.97]
# temporal: date [date], tmax [dbl]
  id           long   lat  elev name                     wmo_id            geometry ts      
  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;         &lt;POINT [°]&gt; &lt;list&gt;  
1 ASN00047016  141. -34.0    43 lake victoria storage     94692 (141.2652 -34.0398) &lt;tbl_ts&gt;
2 ASN00047019  142. -32.4    61 menindee post office      94694 (142.4173 -32.3937) &lt;tbl_ts&gt;
3 ASN00048015  147. -30.0   115 brewarrina hospital       95512 (146.8651 -29.9614) &lt;tbl_ts&gt;
4 ASN00048027  146. -31.5   260 cobar mo                  94711  (145.8294 -31.484) &lt;tbl_ts&gt;
5 ASN00048031  149. -29.5   145 collarenebri (albert st)  95520 (148.5818 -29.5407) &lt;tbl_ts&gt;
# … with 54 more rows
```

???

* Now I'm going to show you how to create a cubble from the spatial and temporal data we have seen before.

* Here you specify the spatial and temporal object in a list with name `spatial` and `temporal`. 

* Then you can specify the `key` and `index` as what you would do  when creating a `tsibble` and `coords` in the order of longitude and latitude. 

--

- There are .sec[59] stations in this data, it is in the nested form and is a subclass of `sf` 
- Temporal variables are `date`, and `tmax`. Spatial variables: `long, lat, elev, name`, and `wmo_id`
- Each temporal component is a tsibble (`tbl_ts`) containing temporal information


???

* By default, this create a nested cubble. 

* There is a header summary on cubble objects, here it tells you

---
# Cubble summary (1/2)

.pull-left-larger[






&lt;code class ='r hljs remark-code'&gt;weather_long &lt;- weather %&gt;% &lt;span style='background-color:#FFEECF'&gt;face_temporal()&lt;/span&gt;&lt;br&gt;weather_long&lt;/code&gt;

```

# cubble:  date, id [59]:
#   long form [tsibble]
# bbox:    [141.26, -39.13,
#   153.37, -28.97]
# spatial: long [dbl], lat
#   [dbl], elev [dbl], name
#   [chr], wmo_id [dbl],
#   geometry [POINT [°]]
  id          date        tmax
  &lt;chr&gt;       &lt;date&gt;     &lt;dbl&gt;
1 ASN00047016 1971-01-01  25  
2 ASN00047016 1971-01-02  26.9
3 ASN00047016 1971-01-03  27.5
4 ASN00047016 1971-01-04  30  
5 ASN00047016 1971-01-05  34.4
# … with 1,099,047 more rows

```

  - now it is a long form cubble and is a subclass of `tsibble`
  
  - the third row now shows the spatial variables

]

--

.pull-right[


```r
attr(weather_long, "spatial") 
```

```
Simple feature collection with 59 features and 6 fields
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 141.2652 ymin: -39.1297 xmax: 153.3633 ymax: -28.9786
Geodetic CRS:  GDA94
# A tibble: 59 × 7
# Rowwise:  id
  id          long   lat  elev
  &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 ASN000470…  141. -34.0    43
2 ASN000470…  142. -32.4    61
3 ASN000480…  147. -30.0   115
4 ASN000480…  146. -31.5   260
5 ASN000480…  149. -29.5   145
# … with 54 more rows, and 3
#   more variables:
#   name &lt;chr&gt;, wmo_id &lt;dbl&gt;,
#   geometry &lt;POINT [°]&gt;
```
  

]

???

* This is what the long cubble looks like

---
# Cubble summary (2/2)






&lt;code class ='r hljs remark-code'&gt;weather_back &lt;- weather_long %&gt;% &lt;span style='background-color:#FFEECF'&gt;face_spatial()&lt;/span&gt;&lt;br&gt;weather_back&lt;/code&gt;

```

# cubble:   id [59]: nested form [sf]
# bbox:     [141.26, -39.13, 153.37, -28.97]
# temporal: date [date], tmax [dbl]
  id           long   lat  elev name                     wmo_id            geometry ts      
  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;         &lt;POINT [°]&gt; &lt;list&gt;  
1 ASN00047016  141. -34.0    43 lake victoria storage     94692 (141.2652 -34.0398) &lt;tibble&gt;
2 ASN00047019  142. -32.4    61 menindee post office      94694 (142.4173 -32.3937) &lt;tibble&gt;
3 ASN00048015  147. -30.0   115 brewarrina hospital       95512 (146.8651 -29.9614) &lt;tibble&gt;
4 ASN00048027  146. -31.5   260 cobar mo                  94711  (145.8294 -31.484) &lt;tibble&gt;
5 ASN00048031  149. -29.5   145 collarenebri (albert st)  95520 (148.5818 -29.5407) &lt;tibble&gt;
# … with 54 more rows

```



&lt;code class ='r hljs remark-code'&gt;identical(weather_back, weather)&lt;/code&gt;

```

[1] FALSE

```
???

* An example of face_spatial() is shown here where you can get the long form back to the nested form. 

* And the output will be identical to the initial cubble `weather` data we created earlier

---

# Pipeline with cubble


???

* In summary, with cubble, you can perform temporal analysis in the long form, and pivot to the nested form for some spatial analysis, and pivot back to the the long form for some other temporal analysis. 

* Sometimes, you may also need to do some analysis that involves both spatial and temporal variables. 

* Here I will show you how to do that in cubble with an example of making glyph maps.

---
# Transform a dot into a glyph

&lt;img src="figures/glyph-steps.png" width="4327" style="display: block; margin: auto;" /&gt;


???

* A glyph map is a transformation of temporal variables into space. 
* Here I have 5 locations, each has a time series. 

* A glyph map transforms the scale of the time series into the spatial map, so that temporal information can be visualised in a map

* To create a glyph map, you will need information on the spatial coordinates, longitude and latitude, which we call the major axes, and the temporal coordinates, date and value, the minor axes.
---

# Transformation to glyphmap

&lt;!-- (context of problem): compare seasonal temperature for two periods  --&gt;

&lt;!-- drop missing --&gt;
&lt;!-- migrate  --&gt;
&lt;!-- transform --&gt;

&lt;!-- What if you want to work with  both spatial or temporal variables? --&gt;

.pull-left[
&lt;img src="figures/migrate.png" width="500" height="400" style="display: block; margin: auto;" /&gt;

]

.pull-right-larger[







&lt;code class ='r hljs remark-code'&gt;cb_migrated &lt;- weather_long %&gt;% unfold(long, lat)&lt;br&gt;cb_migrated&lt;/code&gt;

```

# cubble:  date, id [59]: long form [tsibble]
# bbox:    [141.26, -39.13, 153.37, -28.97]
# spatial: long [dbl], lat [dbl], elev [dbl], name [chr],
#   wmo_id [dbl], geometry [POINT [°]]
  id          date        tmax  long   lat
  &lt;chr&gt;       &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 ASN00047016 1971-01-01  25    141. -34.0
2 ASN00047016 1971-01-02  26.9  141. -34.0
3 ASN00047016 1971-01-03  27.5  141. -34.0
4 ASN00047016 1971-01-04  30    141. -34.0
5 ASN00047016 1971-01-05  34.4  141. -34.0
# … with 1,099,047 more rows, and 1 more variable:
#   geometry &lt;POINT [°]&gt;

```
]

???

* In a cubble, the major coordinates are stored in the nested form, while minor coordinates are stored in the long form.  

* In cubble you can use the verb `unfold()` to relocate spatial variables into the long form. 

* This is in essence a join operation 

* On the right shows an example of unfold long and lat with the weather data.

---

# Example: Australian temperature

&lt;img src="figures/temperature-workflow.png" width="2560" style="display: block; margin: auto;" /&gt;



???

* Now combine everything I have just introduced, here is an example of using cubble to analyse historical temperature

* The data used for this example has a similar structure as before has a long period that dated back to the 70s, so we can compare how the maximum temperature looks like in the past and nowadays

* The diagram here shows how different steps in the data analysis can be chained together with cubble 

* Start with all Australia data, we can first filter out the NSW stations in the space, and then stretch to the long form to filter on the two time periods

* Then with the long form, the maximum temperature is summarised into monthly average

* In step 4 we switch back to the nested form to find that some stations don't have history records and drop those

* In step 5, we switch to the long form again and migrate the longitude and latitude to prepare for the glyph map transformation. 

* And lastly the glyphmap transformation gives you a map.

---


.pull-left-larger[

&lt;br&gt;




&lt;code class ='r hljs remark-code'&gt;tmax &lt;- DATA %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;filter(NSW_STATIONS) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#FFEECF'&gt;face_temporal&lt;/span&gt;() %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;filter(DATE_IN_TWO_GROUPS) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;summarise() %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#FFEECF'&gt;face_spatial&lt;/span&gt;() %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;filter(NO_MISSING_VALUE) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#FFEECF'&gt;face_temporal&lt;/span&gt;() %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#FFEECF'&gt;unfold&lt;/span&gt;(long, lat)&lt;br&gt;&lt;br&gt;tmax %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;ggplot(aes(x_minor = lubridate::month(date), &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;y_minor = tmax, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x_major = long, &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;y_major = lat)) + &lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#FFEECF'&gt;&lt;span style='background-color:#FFEECF'&gt;geom_glyph&lt;/span&gt;_box&lt;/span&gt;() + &lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#FFEECF'&gt;geom_glyph&lt;/span&gt;()&lt;/code&gt;

]

.pull-right[



&lt;img src="index_files/figure-html/unnamed-chunk-28-1.png" width="504" style="display: block; margin: auto;" /&gt;


]

???

* This is the code version of the previous diagram and the functions highlighted here are I developed in cubble

* In the plot, I show an enlarged legend of one station Cobar

* In each glyph, I plot the averaged maximum temperature for September to February for the two periods

* One information I read from this plot is in the past, the average maximum temperature from December to February are almost the same, while these days, January stands out to be hotter for the inland stations






---
class: inverse, middle

# More you can do with cubble

* Merge two data sources by spatial and temporal similarities

--

* Alternative objects accepted as components:

  * Spatial data can be represented as an .inverse-code[sf] or .inverse-code[S2 LngLat], spatial objects

  * Temporal data can be represented as a .inverse-code[tsibble], a special temporal data object

--

* Input data can be of various forms, including .inverse-code[netCDF] and .inverse-code[tibble variates] (i.e. grouped and rowwise data frame)

---
background-image: url("figures/3cubes-in-one.png")
background-position: 90% 70%
background-size: 280px, 280px

class: inverse,  middle

# Additional Information

Slides created via the R package [.inverse-code[xaringan]](https://github.com/yihui/xaringan) and [.inverse-code[xaringanthemer]](https://github.com/gadenbuie/xaringanthemer), available at 

.center[https://sherryzhang-user2022.netlify.app]

&lt;br&gt;

.inverse-code[<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg>] cubble package: https://github.com/huizezhang-sherry/cubble

&lt;br&gt;

H. Sherry Zhang [.inverse-code[<svg aria-hidden="true" role="img" viewBox="0 0 496 512" style="height:1em;width:0.97em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>]](https://github.com/huizezhang-sherry)

Collaborators: Dianne Cook, Patricia Menéndez, Ursula Laa, and Nicolas Langrené



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"navigation": {
"scroll": false,
"touch": true,
"click": false
}
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
